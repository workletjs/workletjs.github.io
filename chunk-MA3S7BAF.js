import{b as ne}from"./chunk-33T4VW6V.js";import{a as re,b as N,c as se}from"./chunk-JFHDADM4.js";import{a as j}from"./chunk-MT2QN4OP.js";import{B as A,D as T,Na as k,a as R,cb as Q,db as Z,hb as $,i as X,lc as ie,mb as ee,nb as te,q as K,w as B,wa as L,z as S}from"./chunk-XJY6H2CM.js";import{B as w,C as m,D as z,E as J,z as P}from"./chunk-XGVPHTK5.js";import{b as _,c as W,da as H,ha as p,ka as b,la as I,m as V,ma as Y}from"./chunk-GF377ULF.js";var oe=0,G=1,ae=[0,0,0,0],E=[],U={MODIFYSTART:"modifystart",MODIFYEND:"modifyend"},D=class extends K{constructor(e,t,i){super(e),this.features=t,this.mapBrowserEvent=i}},O=class extends te{constructor(e){super(e),this.on,this.once,this.un,this.boundHandleFeatureChange_=this.handleFeatureChange_.bind(this),this.condition_=e.condition?e.condition:ee,this.defaultDeleteCondition_=function(i){return Q(i)&&$(i)},this.deleteCondition_=e.deleteCondition?e.deleteCondition:this.defaultDeleteCondition_,this.insertVertexCondition_=e.insertVertexCondition?e.insertVertexCondition:Z,this.vertexFeature_=null,this.vertexSegments_=null,this.lastPixel_=[0,0],this.ignoreNextSingleClick_=!1,this.featuresBeingModified_=null,this.rBush_=new re,this.pixelTolerance_=e.pixelTolerance!==void 0?e.pixelTolerance:10,this.snappedToVertex_=!1,this.changingFeature_=!1,this.dragSegments_=[],this.overlay_=new ne({source:new se({useSpatialIndex:!1,wrapX:!!e.wrapX}),style:e.style?e.style:de(),updateWhileAnimating:!0,updateWhileInteracting:!0}),this.SEGMENT_WRITERS_={Point:this.writePointGeometry_.bind(this),LineString:this.writeLineStringGeometry_.bind(this),LinearRing:this.writeLineStringGeometry_.bind(this),Polygon:this.writePolygonGeometry_.bind(this),MultiPoint:this.writeMultiPointGeometry_.bind(this),MultiLineString:this.writeMultiLineStringGeometry_.bind(this),MultiPolygon:this.writeMultiPolygonGeometry_.bind(this),Circle:this.writeCircleGeometry_.bind(this),GeometryCollection:this.writeGeometryCollectionGeometry_.bind(this)},this.source_=null,this.hitDetection_=null;let t;if(e.features?t=e.features:e.source&&(this.source_=e.source,t=new A(this.source_.getFeatures()),this.source_.addEventListener(N.ADDFEATURE,this.handleSourceAdd_.bind(this)),this.source_.addEventListener(N.REMOVEFEATURE,this.handleSourceRemove_.bind(this))),!t)throw new Error("The modify interaction requires features, a source or a layer");e.hitDetection&&(this.hitDetection_=e.hitDetection),this.features_=t,this.features_.forEach(this.addFeature_.bind(this)),this.features_.addEventListener(B.ADD,this.handleFeatureAdd_.bind(this)),this.features_.addEventListener(B.REMOVE,this.handleFeatureRemove_.bind(this)),this.lastPointerEvent_=null,this.delta_=[0,0],this.snapToPointer_=e.snapToPointer===void 0?!this.hitDetection_:e.snapToPointer}addFeature_(e){let t=e.getGeometry();if(t){let n=this.SEGMENT_WRITERS_[t.getType()];n&&n(e,t)}let i=this.getMap();i&&i.isRendered()&&this.getActive()&&this.handlePointerAtPixel_(i.getCoordinateFromPixel(this.lastPixel_)),e.addEventListener(R.CHANGE,this.boundHandleFeatureChange_)}willModifyFeatures_(e,t){if(!this.featuresBeingModified_){this.featuresBeingModified_=new A;let i=this.featuresBeingModified_.getArray();for(let n=0,r=t.length;n<r;++n){let o=t[n].feature;o&&!i.includes(o)&&this.featuresBeingModified_.push(o)}this.featuresBeingModified_.getLength()===0?this.featuresBeingModified_=null:this.dispatchEvent(new D(U.MODIFYSTART,this.featuresBeingModified_,e))}}removeFeature_(e){this.removeFeatureSegmentData_(e),this.vertexFeature_&&this.features_.getLength()===0&&(this.overlay_.getSource().removeFeature(this.vertexFeature_),this.vertexFeature_=null),e.removeEventListener(R.CHANGE,this.boundHandleFeatureChange_)}removeFeatureSegmentData_(e){let t=this.rBush_,i=[];t.forEach(function(n){e===n.feature&&i.push(n)});for(let n=i.length-1;n>=0;--n){let r=i[n];for(let o=this.dragSegments_.length-1;o>=0;--o)this.dragSegments_[o][0]===r&&this.dragSegments_.splice(o,1);t.remove(r)}}setActive(e){this.vertexFeature_&&!e&&(this.overlay_.getSource().removeFeature(this.vertexFeature_),this.vertexFeature_=null),super.setActive(e)}setMap(e){this.overlay_.setMap(e),super.setMap(e)}getOverlay(){return this.overlay_}handleSourceAdd_(e){e.feature&&this.features_.push(e.feature)}handleSourceRemove_(e){e.feature&&this.features_.remove(e.feature)}handleFeatureAdd_(e){this.addFeature_(e.element)}handleFeatureChange_(e){if(!this.changingFeature_){let t=e.target;this.removeFeature_(t),this.addFeature_(t)}}handleFeatureRemove_(e){this.removeFeature_(e.element)}writePointGeometry_(e,t){let i=t.getCoordinates(),n={feature:e,geometry:t,segment:[i,i]};this.rBush_.insert(t.getExtent(),n)}writeMultiPointGeometry_(e,t){let i=t.getCoordinates();for(let n=0,r=i.length;n<r;++n){let o=i[n],h={feature:e,geometry:t,depth:[n],index:n,segment:[o,o]};this.rBush_.insert(t.getExtent(),h)}}writeLineStringGeometry_(e,t){let i=t.getCoordinates();for(let n=0,r=i.length-1;n<r;++n){let o=i.slice(n,n+2),h={feature:e,geometry:t,index:n,segment:o};this.rBush_.insert(_(o),h)}}writeMultiLineStringGeometry_(e,t){let i=t.getCoordinates();for(let n=0,r=i.length;n<r;++n){let o=i[n];for(let h=0,s=o.length-1;h<s;++h){let a=o.slice(h,h+2),u={feature:e,geometry:t,depth:[n],index:h,segment:a};this.rBush_.insert(_(a),u)}}}writePolygonGeometry_(e,t){let i=t.getCoordinates();for(let n=0,r=i.length;n<r;++n){let o=i[n];for(let h=0,s=o.length-1;h<s;++h){let a=o.slice(h,h+2),u={feature:e,geometry:t,depth:[n],index:h,segment:a};this.rBush_.insert(_(a),u)}}}writeMultiPolygonGeometry_(e,t){let i=t.getCoordinates();for(let n=0,r=i.length;n<r;++n){let o=i[n];for(let h=0,s=o.length;h<s;++h){let a=o[h];for(let u=0,c=a.length-1;u<c;++u){let d=a.slice(u,u+2),g={feature:e,geometry:t,depth:[h,n],index:u,segment:d};this.rBush_.insert(_(d),g)}}}}writeCircleGeometry_(e,t){let i=t.getCenter(),n={feature:e,geometry:t,index:oe,segment:[i,i]},r={feature:e,geometry:t,index:G,segment:[i,i]},o=[n,r];n.featureSegments=o,r.featureSegments=o,this.rBush_.insert(V(i),n);let h=t,s=P();if(s&&this.getMap()){let a=this.getMap().getView().getProjection();h=h.clone().transform(s,a),h=k(h).transform(a,s)}this.rBush_.insert(h.getExtent(),r)}writeGeometryCollectionGeometry_(e,t){let i=t.getGeometriesArray();for(let n=0;n<i.length;++n){let r=i[n],o=this.SEGMENT_WRITERS_[r.getType()];o(e,r)}}createOrUpdateVertexFeature_(e,t,i,n){let r=this.vertexFeature_;return r?r.getGeometry().setCoordinates(e):(r=new j(new L(e)),this.vertexFeature_=r,this.overlay_.getSource().addFeature(r)),r.set("features",t),r.set("geometries",i),r.set("existing",n),r}handleEvent(e){if(!e.originalEvent)return!0;this.lastPointerEvent_=e;let t;return!e.map.getView().getInteracting()&&e.type==T.POINTERMOVE&&!this.handlingDownUpSequence&&this.handlePointerMove_(e),this.vertexFeature_&&this.deleteCondition_(e)&&(e.type!=T.SINGLECLICK||!this.ignoreNextSingleClick_?t=this.removePoint():t=!0),e.type==T.SINGLECLICK&&(this.ignoreNextSingleClick_=!1),super.handleEvent(e)&&!t}findInsertVerticesAndUpdateDragSegments_(e){this.handlePointerAtPixel_(e),this.dragSegments_.length=0,this.featuresBeingModified_=null;let t=this.vertexFeature_;if(!t)return;let i=this.getMap().getView().getProjection(),n=[],r=t.getGeometry().getCoordinates(),o=_([r]),h=this.rBush_.getInExtent(o),s={};h.sort(ce);for(let a=0,u=h.length;a<u;++a){let c=h[a],d=c.segment,g=S(c.geometry),l=c.depth;if(l&&(g+="-"+l.join("-")),s[g]||(s[g]=new Array(2)),c.geometry.getType()==="Circle"&&c.index===G){let f=ge(e,c,i);p(f,r)&&!s[g][0]&&(this.dragSegments_.push([c,0]),s[g][0]=c);continue}if(p(d[0],r)&&!s[g][0]){this.dragSegments_.push([c,0]),s[g][0]=c;continue}if(p(d[1],r)&&!s[g][1]){if(s[g][0]&&s[g][0].index===0){let f=c.geometry.getCoordinates();switch(c.geometry.getType()){case"LineString":case"MultiLineString":continue;case"MultiPolygon":f=f[l[1]];case"Polygon":if(c.index!==f[l[0]].length-2)continue;break;default:}}this.dragSegments_.push([c,1]),s[g][1]=c;continue}S(d)in this.vertexSegments_&&!s[g][0]&&!s[g][1]&&n.push(c)}return n}handleDragEvent(e){this.ignoreNextSingleClick_=!1,this.willModifyFeatures_(e,this.dragSegments_.map(([r])=>r));let t=[e.coordinate[0]+this.delta_[0],e.coordinate[1]+this.delta_[1]],i=[],n=[];for(let r=0,o=this.dragSegments_.length;r<o;++r){let h=this.dragSegments_[r],s=h[0],a=s.feature;i.includes(a)||i.push(a);let u=s.geometry;n.includes(u)||n.push(u);let c=s.depth,d,g=s.segment,l=h[1];for(;t.length<u.getStride();)t.push(g[l][t.length]);switch(u.getType()){case"Point":d=t,g[0]=t,g[1]=t;break;case"MultiPoint":d=u.getCoordinates(),d[s.index]=t,g[0]=t,g[1]=t;break;case"LineString":d=u.getCoordinates(),d[s.index+l]=t,g[l]=t;break;case"MultiLineString":d=u.getCoordinates(),d[c[0]][s.index+l]=t,g[l]=t;break;case"Polygon":d=u.getCoordinates(),d[c[0]][s.index+l]=t,g[l]=t;break;case"MultiPolygon":d=u.getCoordinates(),d[c[1]][c[0]][s.index+l]=t,g[l]=t;break;case"Circle":let f=u;if(g[0]=t,g[1]=t,s.index===oe)this.changingFeature_=!0,f.setCenter(t),this.changingFeature_=!1;else{this.changingFeature_=!0;let y=e.map.getView().getProjection(),v=I(m(f.getCenter(),y),m(t,y)),C=P();if(C){let F=f.clone().transform(C,y);F.setRadius(v),v=F.transform(y,C).getRadius()}f.setRadius(v),this.changingFeature_=!1}break;default:}d&&this.setGeometryCoordinates_(u,d)}this.createOrUpdateVertexFeature_(t,i,n,!0)}handleDownEvent(e){if(!this.condition_(e))return!1;let t=e.coordinate,i=this.findInsertVerticesAndUpdateDragSegments_(t);if(i?.length&&this.insertVertexCondition_(e)&&(this.willModifyFeatures_(e,i),this.vertexFeature_)){let n=this.vertexFeature_.getGeometry().getCoordinates();for(let r=i.length-1;r>=0;--r)this.insertVertex_(i[r],n);this.ignoreNextSingleClick_=!0}return!!this.vertexFeature_}handleUpEvent(e){for(let t=this.dragSegments_.length-1;t>=0;--t){let i=this.dragSegments_[t][0],n=i.geometry;if(n.getType()==="Circle"){let r=n,o=r.getCenter(),h=i.featureSegments[0],s=i.featureSegments[1];h.segment[0]=o,h.segment[1]=o,s.segment[0]=o,s.segment[1]=o,this.rBush_.update(V(o),h);let a=r,u=P();if(u){let c=e.map.getView().getProjection();a=a.clone().transform(u,c),a=k(a).transform(c,u)}this.rBush_.update(a.getExtent(),s)}else this.rBush_.update(_(i.segment),i)}return this.featuresBeingModified_&&(this.dispatchEvent(new D(U.MODIFYEND,this.featuresBeingModified_,e)),this.featuresBeingModified_=null),!1}handlePointerMove_(e){this.lastPixel_=e.pixel,this.handlePointerAtPixel_(e.coordinate)}handlePointerAtPixel_(e){let t=this.getMap(),i=t.getPixelFromCoordinate(e),n=t.getView().getProjection(),r=function(s,a){return he(e,s,n)-he(e,a,n)},o,h;if(this.hitDetection_){let s=typeof this.hitDetection_=="object"?a=>a===this.hitDetection_:void 0;t.forEachFeatureAtPixel(i,(a,u,c)=>{c&&c.getType()==="Point"&&(c=new L(w(c.getCoordinates(),n)));let d=c||a.getGeometry();if(d&&d.getType()==="Point"&&a instanceof j&&this.features_.getArray().includes(a)){h=d;let g=a.getGeometry().getFlatCoordinates().slice(0,2);o=[{feature:a,geometry:h,segment:[g,g]}]}return!0},{layerFilter:s})}if(!o){let s=J(V(e,ae),n),a=t.getView().getResolution()*this.pixelTolerance_,u=z(W(s,a,ae),n);o=this.rBush_.getInExtent(u)}if(o&&o.length>0){let s=o.sort(r)[0],a=s.segment,u=ge(e,s,n),c=t.getPixelFromCoordinate(u),d=I(i,c);if(h||d<=this.pixelTolerance_){let g={};if(g[S(a)]=!0,this.snapToPointer_||(this.delta_[0]=u[0]-e[0],this.delta_[1]=u[1]-e[1]),s.geometry.getType()==="Circle"&&s.index===G)this.snappedToVertex_=!0,this.createOrUpdateVertexFeature_(u,[s.feature],[s.geometry],this.snappedToVertex_);else{let l=t.getPixelFromCoordinate(a[0]),f=t.getPixelFromCoordinate(a[1]),y=b(c,l),v=b(c,f);if(d=Math.sqrt(Math.min(y,v)),this.snappedToVertex_=d<=this.pixelTolerance_,!this.snappedToVertex_&&!this.insertVertexCondition_(this.lastPointerEvent_)){this.vertexFeature_&&(this.overlay_.getSource().removeFeature(this.vertexFeature_),this.vertexFeature_=null);return}this.snappedToVertex_&&(u=y>v?a[1]:a[0]),this.createOrUpdateVertexFeature_(u,[s.feature],[s.geometry],this.snappedToVertex_);let C={};C[S(s.geometry)]=!0;for(let F=1,ue=o.length;F<ue;++F){let M=o[F].segment;if(p(a[0],M[0])&&p(a[1],M[1])||p(a[0],M[1])&&p(a[1],M[0])){let q=S(o[F].geometry);q in C||(C[q]=!0,g[S(M)]=!0)}else break}}this.vertexSegments_=g;return}}this.vertexFeature_&&(this.overlay_.getSource().removeFeature(this.vertexFeature_),this.vertexFeature_=null)}insertVertex_(e,t){let i=e.segment,n=e.feature,r=e.geometry,o=e.depth,h=e.index,s;for(;t.length<r.getStride();)t.push(0);switch(r.getType()){case"MultiLineString":s=r.getCoordinates(),s[o[0]].splice(h+1,0,t);break;case"Polygon":s=r.getCoordinates(),s[o[0]].splice(h+1,0,t);break;case"MultiPolygon":s=r.getCoordinates(),s[o[1]][o[0]].splice(h+1,0,t);break;case"LineString":s=r.getCoordinates(),s.splice(h+1,0,t);break;default:return!1}this.setGeometryCoordinates_(r,s);let a=this.rBush_;a.remove(e),this.updateSegmentIndices_(r,h,o,1);let u={segment:[i[0],t],feature:n,geometry:r,depth:o,index:h};a.insert(_(u.segment),u),this.dragSegments_.push([u,1]);let c={segment:[t,i[1]],feature:n,geometry:r,depth:o,index:h+1};return a.insert(_(c.segment),c),this.dragSegments_.push([c,0]),!0}updatePointer_(e){return e&&this.findInsertVerticesAndUpdateDragSegments_(e),this.vertexFeature_?.getGeometry().getCoordinates()}getPoint(){let e=this.vertexFeature_?.getGeometry().getCoordinates();return e?w(e,this.getMap().getView().getProjection()):null}canRemovePoint(){if(!this.vertexFeature_||this.vertexFeature_.get("geometries").every(i=>i.getType()==="Circle"||i.getType().endsWith("Point")))return!1;let e=this.vertexFeature_.getGeometry().getCoordinates();return this.rBush_.getInExtent(_([e])).some(({segment:i})=>p(i[0],e)||p(i[1],e))}removePoint(e){if(e&&(e=m(e,this.getMap().getView().getProjection()),this.updatePointer_(e)),!this.lastPointerEvent_||this.lastPointerEvent_&&this.lastPointerEvent_.type!=T.POINTERDRAG){let t=this.lastPointerEvent_;this.willModifyFeatures_(t,this.dragSegments_.map(([n])=>n));let i=this.removeVertex_();return this.featuresBeingModified_&&this.dispatchEvent(new D(U.MODIFYEND,this.featuresBeingModified_,t)),this.featuresBeingModified_=null,i}return!1}removeVertex_(){let e=this.dragSegments_,t={},i=!1,n,r,o,h,s,a,u,c,d,g,l;for(s=e.length-1;s>=0;--s)o=e[s],g=o[0],l=S(g.feature),g.depth&&(l+="-"+g.depth.join("-")),l in t||(t[l]={}),o[1]===0?(t[l].right=g,t[l].index=g.index):o[1]==1&&(t[l].left=g,t[l].index=g.index+1);for(l in t){switch(d=t[l].right,u=t[l].left,a=t[l].index,c=a-1,u!==void 0?g=u:g=d,c<0&&(c=0),h=g.geometry,r=h.getCoordinates(),n=r,i=!1,h.getType()){case"MultiLineString":r[g.depth[0]].length>2&&(r[g.depth[0]].splice(a,1),i=!0);break;case"LineString":r.length>2&&(r.splice(a,1),i=!0);break;case"MultiPolygon":n=n[g.depth[1]];case"Polygon":n=n[g.depth[0]],n.length>4&&(a==n.length-1&&(a=0),n.splice(a,1),i=!0,a===0&&(n.pop(),n.push(n[0]),c=n.length-1));break;default:}if(i){this.setGeometryCoordinates_(h,r);let f=[];if(u!==void 0&&(this.rBush_.remove(u),f.push(u.segment[0])),d!==void 0&&(this.rBush_.remove(d),f.push(d.segment[1])),u!==void 0&&d!==void 0){let y={depth:g.depth,feature:g.feature,geometry:g.geometry,index:c,segment:f};this.rBush_.insert(_(y.segment),y)}this.updateSegmentIndices_(h,a,g.depth,-1),this.vertexFeature_&&(this.overlay_.getSource().removeFeature(this.vertexFeature_),this.vertexFeature_=null),e.length=0}}return i}canInsertPoint(){if(!this.vertexFeature_||this.vertexFeature_.get("geometries").every(i=>i.getType()==="Circle"||i.getType().endsWith("Point")))return!1;let e=this.vertexFeature_.getGeometry().getCoordinates();return this.rBush_.getInExtent(_([e])).some(({segment:i})=>!(p(i[0],e)||p(i[1],e)))}insertPoint(e){let t=e?m(e,this.getMap().getView().getProjection()):this.vertexFeature_?.getGeometry().getCoordinates();return t?this.findInsertVerticesAndUpdateDragSegments_(t).reduce((n,r)=>n||this.insertVertex_(r,t),!1):!1}setGeometryCoordinates_(e,t){this.changingFeature_=!0,e.setCoordinates(t),this.changingFeature_=!1}updateSegmentIndices_(e,t,i,n){this.rBush_.forEachInExtent(e.getExtent(),function(r){r.geometry===e&&(i===void 0||r.depth===void 0||X(r.depth,i))&&r.index>t&&(r.index+=n)})}};function ce(x,e){return x.index-e.index}function he(x,e,t){let i=e.geometry;if(i.getType()==="Circle"){let r=i;if(e.index===G){let o=P();o&&(r=r.clone().transform(o,t));let h=b(r.getCenter(),m(x,t)),s=Math.sqrt(h)-r.getRadius();return s*s}}let n=m(x,t);return E[0]=m(e.segment[0],t),E[1]=m(e.segment[1],t),Y(n,E)}function ge(x,e,t){let i=e.geometry;if(i.getType()==="Circle"&&e.index===G){let r=i,o=P();return o&&(r=r.clone().transform(o,t)),w(r.getClosestPoint(m(x,t)),t)}let n=m(x,t);return E[0]=m(e.segment[0],t),E[1]=m(e.segment[1],t),w(H(n,E),t)}function de(){let x=ie();return function(e,t){return x.Point}}var Ie=O;export{Ie as a};
